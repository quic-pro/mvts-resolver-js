import { Signer } from '@ethersproject/abstract-signer';
import { Provider } from '@ethersproject/abstract-provider';
import Base from './Base';
import { address, uint256, bytes, PayableOptions } from './types';
declare enum CodeMode {
    Number = 0,
    Pool = 1
}
type Router = {
    0: string;
    1: address;
    2: string;
    chainId: string;
    adr: address;
    poolCodeLength: string;
};
type Code = {
    0: boolean;
    1: boolean;
    2: boolean;
    3: uint256;
    4: CodeMode;
    5: string;
    6: Router;
    isBlocked: boolean;
    hasSipDomain: boolean;
    hasRouter: boolean;
    subscriptionEndTime: uint256;
    mode: CodeMode;
    sipDomain: string;
    router: Router;
};
type CodeStatus = {
    0: boolean;
    1: boolean;
    2: boolean;
    3: boolean;
    4: uint256;
    5: uint256;
    isBlocked: boolean;
    isAvailable: boolean;
    isHeld: boolean;
    isAvailableForBuy: boolean;
    subscriptionEndTime: uint256;
    holdEndTime: uint256;
};
export default class RootRouter extends Base {
    constructor(addressOrName: address | string, signerOrProvider: Signer | Provider);
    mintPrice(): Promise<uint256>;
    subscriptionPrice(): Promise<uint256>;
    modeChangePrice(): Promise<uint256>;
    subscriptionDuration(): Promise<uint256>;
    holdingDuration(): Promise<uint256>;
    ttl(): Promise<uint256>;
    baseUri(): Promise<string>;
    defaultSipDomain(): Promise<string>;
    owner(): Promise<string>;
    name(): Promise<string>;
    symbol(): Promise<string>;
    POOL_SIZE(): Promise<uint256>;
    supportsInterface(interfaceId: bytes): Promise<boolean>;
    tokenURI(tokenId: uint256): Promise<string>;
    balanceOf(owner: address): Promise<number>;
    ownerOf(tokenId: uint256): Promise<string>;
    hasOwner(code: uint256): Promise<boolean>;
    getCodeData(code: uint256): Promise<Code>;
    isBlocked(code: uint256): Promise<boolean>;
    isHeld(code: uint256): Promise<boolean>;
    isAvailableForBuy(code: uint256): Promise<boolean>;
    isNumberMode(code: uint256): Promise<boolean>;
    isPoolMode(code: uint256): Promise<boolean>;
    getMode(code: uint256): Promise<CodeMode>;
    getCodeStatus(code: uint256): Promise<CodeStatus>;
    getBlockedCodes(): Promise<boolean[]>;
    getHeldCodes(): Promise<boolean[]>;
    getAvailableForMintCodes(): Promise<boolean[]>;
    getPoolCodes(): Promise<boolean[]>;
    getOwnerCodes(adr: address): Promise<boolean[]>;
    withdraw(): Promise<void>;
    setMintPrice(newMintPrice: uint256): Promise<void>;
    setSubscriptionPrice(newSubscriptionPrice: uint256): Promise<void>;
    setModeChangePrice(newModeChangePrice: uint256): Promise<void>;
    setSubscriptionDuration(newSubscriptionDuration: uint256): Promise<void>;
    setHoldingDuration(newHoldingDuration: uint256): Promise<void>;
    setTtl(newTtl: uint256): Promise<void>;
    setDefaultSipDomain(newDefaultSipDomain: string): Promise<void>;
    setBaseUri(newBaseUri: string): Promise<void>;
    setCodeBlockedStatus(code: uint256, newBlockedStatus: boolean): Promise<void>;
    setCodeSubscriptionEndTime(code: uint256, newSubscriptionEndTime: uint256): Promise<void>;
    safeTransferFrom(from: address, to: address, tokenId: uint256, data?: bytes): Promise<void>;
    transferFrom(from: address, to: address, tokenId: uint256): Promise<void>;
    approve(to: address, tokenId: uint256): Promise<void>;
    setApprovalForAll(operator: address, approved: boolean): Promise<void>;
    getApproved(tokenId: uint256): Promise<string>;
    isApprovedForAll(owner: address, operator: address): Promise<boolean>;
    mint(code: uint256, options: PayableOptions): Promise<void>;
    renewSubscription(code: uint256, options: PayableOptions): Promise<void>;
    transferOwnershipOfCode(code: uint256, newOwner: address): Promise<void>;
    renounceOwnershipOfCode(code: uint256): Promise<void>;
    changeCodeMode(code: uint256): Promise<void>;
    setCodeSipDomain(code: uint256, newSipDomain: string): Promise<void>;
    clearCodeSipDomain(code: uint256): Promise<void>;
    setCodeRouter(code: uint256, newChainId: uint256, newAdr: address, newPoolCodeLength: uint256): Promise<void>;
    clearCodeRouter(code: uint256): Promise<void>;
    getNextNode(code: uint256): Promise<string[]>;
}
export {};
